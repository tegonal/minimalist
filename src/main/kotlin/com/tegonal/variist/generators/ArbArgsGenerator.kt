package com.tegonal.variist.generators

import com.tegonal.variist.config.ComponentFactoryContainerProvider
import com.tegonal.variist.config.VariistConfig
import com.tegonal.variist.generators.impl.DefaultArbExtensionPoint
import com.tegonal.variist.utils.createVariistRandom

/**
 * Represents an [ArgsGenerator] which provides [generate] which generates [T]s an infinite number of times in a random
 * or not defined order.
 *
 * Note, every [ArbArgsGenerator] also needs to implement [CoreArbArgsGenerator]. You can then use [_core] to transform
 * an [ArbArgsGenerator] into a [CoreArbArgsGenerator].
 *
 * @param T the type of values generated by `this` [ArbArgsGenerator].
 *
 * @since 2.0.0
 */
// TODO 2.1.0 introduce something like ArbArgsSizeAwareGenerator which has a size and
//  provides a way to turn itself into an OrderedArgsGenerator. This would be useful for small spaces as we could just
//  return all values in case an ArgsRangeDecider decides to take more then the available size
interface ArbArgsGenerator<out T> : ArgsGenerator<T> {
	/**
	 * Returns one random value of type [T].
	 *
	 * @since 2.0.0
	 */
	fun generateOne(seedOffset: Int = 0): T =
		// we don't use first as it checks hasNext in addition and we know that it has to have one as the
		// Sequence needs to be infinite according to the ArgsGenerator contract
		generate(seedOffset).iterator().next()

	/**
	 * Generates an infinite stream of random values of type [T].
	 *
	 * @param seedOffset an offset to [VariistConfig.seed] which shall be applied in
	 *   case this [ArbArgsGenerator] relies on [createVariistRandom].
	 * @since 2.0.0
	 */
	fun generate(seedOffset: Int = 0): Sequence<T>
}

/**
 * Represents an interface each [ArbArgsGenerator] should implement and providing additional core functionality which
 * is relevant for users which create own [ArbArgsGenerator]s or combiner functions.
 *
 * The separation between [ArbArgsGenerator] and [CoreArbArgsGenerator] makes sure the API stays clean for
 * regular users which just use [arb] but don't define own [ArbArgsGenerator] implementations.
 *
 * @since 2.0.0
 */
interface CoreArbArgsGenerator<out T> : ArbArgsGenerator<T>, ComponentFactoryContainerProvider {
	val seedBaseOffset: Int
}

/**
 * Creates an [ArbExtensionPoint] based on `this` [CoreArbArgsGenerator].
 *
 * @since 2.0.0
 */
val <T> CoreArbArgsGenerator<T>.arb: ArbExtensionPoint
	get() = DefaultArbExtensionPoint(componentFactoryContainer, seedBaseOffset)

/**
 * Casts `this` to a [CoreArbArgsGenerator].
 *
 * @since 2.0.0
 */
@Suppress("ObjectPropertyName")
val <T> ArbArgsGenerator<T>._core: CoreArbArgsGenerator<T>
	get() = when (this) {
		is CoreArbArgsGenerator<T> -> this
		else -> error("The ArbArgsGenerator ${this::class.qualifiedName} does not implement ${CoreArbArgsGenerator::class.qualifiedName}, please inform the author.")
	}
