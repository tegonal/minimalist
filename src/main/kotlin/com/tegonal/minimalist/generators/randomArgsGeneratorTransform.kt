// --------------------------------------------------------------------------------------------------------------------
// automatically generated, don't modify here but in:
// gradle/code-generation/src/main/kotlin/code-generation.generate.gradle.kts => generate
// --------------------------------------------------------------------------------------------------------------------
package com.tegonal.minimalist.generators

import com.tegonal.minimalist.generators.impl.RandomArgsGeneratorTransformer

/**
 * Maps the values `this` [RandomArgsGenerator] generates to type [R] with the help of the given [transform] function.
 *
 * @param transform The transformation function which takes a [T] and produces an [R].
 *
 * @param T The type of values generated by `this` [RandomArgsGenerator].
 * @param R the type of values generated by the resulting [RandomArgsGenerator].
 *
 * @return The resulting [RandomArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> RandomArgsGenerator<T>.map(transform: (T) -> R): RandomArgsGenerator<R> =
	this.transform { it.map(transform) }

/**
 * Filters the [Sequence] of values `this` [RandomArgsGenerator] will [generate][RandomArgsGenerator.generate] which
 * match the given [predicate] - should not filter out all values otherwise it will break the [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own RandomArgsGenerator
 * which only generates the desired values instead of filtering as `this` [RandomArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that matches the given [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be kept in the sequence, otherwise `false`.
 *
 * @param T The type of values generated by `this` [RandomArgsGenerator].
 *
 * @return The resulting [RandomArgsGenerator] which generates only values for which
 *   the given [predicate] returns `true`.
 *
 * @since 2.0.0
 */
fun <T> RandomArgsGenerator<T>.filter(predicate: (T) -> Boolean): RandomArgsGenerator<T> =
	this.transform { it.filter(predicate) }

/**
 * Filters the [Sequence] of values `this` [RandomArgsGenerator] will [generate][RandomArgsGenerator.generate] which
 * do **not** match the given [predicate] - should not filter out all values otherwise it will break the
 * [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own RandomArgsGenerator
 * which only generates the desired values instead of filtering as `this` [RandomArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that does not match the given
 * [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be filtered out, otherwise `false`.
 *
 * @param T The type of values generated by `this` [RandomArgsGenerator].
 *
 * @return The resulting [RandomArgsGenerator] which generates only values for which
 *   the given [predicate] returns `false`.
 *
 * @since 2.0.0
 */
fun <T> RandomArgsGenerator<T>.filterNot(predicate: (T) -> Boolean): RandomArgsGenerator<T> =
	this.transform { it.filterNot(predicate) }

/**
 * Transforms the [Sequence] `this` [RandomArgsGenerator] will generate into a [Sequence] of type [R] and thus creating a
 * [RandomArgsGenerator] of type [R].
 *
 * Note that the resulting sequence must still be an infinite stream of values.
 *
 * @param transform The transformation function which takes a [Sequence] of type [T] and
 *   produces a [Sequence] of type [R].
 *
 * @param T The type of values generated by `this` [RandomArgsGenerator].
 * @param R the type of values generated by the resulting [RandomArgsGenerator].
 *
 * @return The resulting [RandomArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> RandomArgsGenerator<T>.transform(transform: (Sequence<T>) -> Sequence<R>): RandomArgsGenerator<R> =
	RandomArgsGeneratorTransformer(this, transform)
