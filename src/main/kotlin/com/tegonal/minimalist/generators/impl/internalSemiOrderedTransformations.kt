package com.tegonal.minimalist.generators.impl

import com.tegonal.minimalist.config.MinimalistConfig
import com.tegonal.minimalist.config._components
import com.tegonal.minimalist.config.config
import com.tegonal.minimalist.generators.ArbArgsGenerator
import com.tegonal.minimalist.generators.SemiOrderedArgsGenerator


/**
 * Maps the values `this` [SemiOrderedArgsGenerator] generates together with an index to type [R] with the help of the
 * given [transform] function.
 *
 * !! No backward compatibility guarantees !!
 * Reuse at your own risk
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset] and this regardless what `offset` is used in the end
 *
 * @param transform The transformation function which takes a [T] and produces an [R].
 *
 * @param T The type of values generated by `this` [SemiOrderedArgsGenerator].
 * @param R the type of values generated by the resulting [SemiOrderedArgsGenerator].
 *
 * @return The resulting [SemiOrderedArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
@InternalDangerousApi
fun <T, R> SemiOrderedArgsGenerator<T>.mapIndexedInternal(transform: (index: Int, T) -> R): SemiOrderedArgsGenerator<R> =
	transformInternal { seq ->
		val offset = _components.config.offsetToDecidedOffset
		if (offset == null) {
			seq.mapIndexed(transform)
		} else {
			seq.mapIndexed { index, it ->
				transform(
					// expected that this overflows in the worst case
					index + offset,
					it,
				)
			}
		}
	}


/**
 * Maps the values `this` [ArbArgsGenerator] generates together with an index to a finite
 * [Sequence]`<R>` with the help of the given [transform] function and then flattens them so that the
 * resulting [ArbArgsGenerator] returns values of type [R].
 *
 * !! No backward compatibility guarantees !!
 * Reuse at your own risk
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset].
 *
 * Use the overload which provides the `seedOffset` in case you use [ArbArgsGenerator.generate] inside the [transform]
 * function, this way you can pass on the `seedOffset` to [ArbArgsGenerator.generate].
 *
 * @param transform The transformation function which takes a [T] and an index and produces a
 *   finite [Sequence] of elements of type [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
@InternalDangerousApi
fun <T, R> SemiOrderedArgsGenerator<T>.flatMapIndexedInternal(transform: (index: Int, T) -> Sequence<R>): SemiOrderedArgsGenerator<R> =
	transformInternal { seq ->
		val offsetToDecidedOffset = _components.config.offsetToDecidedOffset
		if (offsetToDecidedOffset == null) {
			seq.flatMapIndexed(transform)
		} else {
			seq.flatMapIndexed { index, it ->
				transform(
					// expected that this overflows in the worst case
					index + offsetToDecidedOffset,
					it,
				)
			}
		}
	}

/**
 * !! No backward compatibility guarantees !!
 * Reuse at your own risk
 *
 * Note, we tried to re-use OrderedArgsGeneratorTransformer for other operations by providing a generic transform
 * extension method which required a newSize in addition. Yet, we ran into 3 bugs in a row, so it seems it is
 * too dangerous to leave it into the wild. In particular one needs to take care of:
 * - that the newSize is actually correct (we cannot check this)
 * - the offset still works as it should. For instance, filtering means the offset has to happen after generation,
 *   i.e. dropping elements and this can harm performance in case there are a lot of values (which can happen easily
 *   when combining generators). The same problem applies when adding elements (e.g. via flatMap). Something like
 *   Sequence.chunked needs extra care as the resulting stream should be ordered finite, repeating after size
 *
 * Use this method only if you are more than convinced that the resulting Sequence still has the same semantics as the
 * original in terms of order, OrderedArgsGenerator.size, and a used offset
 *
 */
@InternalDangerousApi
fun <R, T> SemiOrderedArgsGenerator<T>.transformInternal(transform: (Sequence<T>) -> Sequence<R>): SemiOrderedArgsGeneratorTransformer<T, R> =
	SemiOrderedArgsGeneratorTransformer(this, transform)


