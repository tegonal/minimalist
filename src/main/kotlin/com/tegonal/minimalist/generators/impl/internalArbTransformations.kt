package com.tegonal.minimalist.generators.impl

import com.tegonal.minimalist.config.MinimalistConfig
import com.tegonal.minimalist.config._components
import com.tegonal.minimalist.config.config
import com.tegonal.minimalist.generators.ArbArgsGenerator
import com.tegonal.minimalist.generators.transform

/**
 * Maps the values `this` [ArbArgsGenerator] generates together with an index and a seed offset to type [R]
 * with the help of the given [transform] function.
 *
 * !! No backward compatibility guarantees !!
 * Reuse at your own risk
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset].
 *
 * @param transform The transformation function which takes a [T], an index and a seed offset and produces an [R].
 *   The `seedOffset` is passed along the call chain and should be taken into account when using
 *   [ArbArgsGenerator.generate] inside the transform function.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.mapIndexedInternal(
	transform: (index: Int, T, seedOffset: Int) -> R
): ArbArgsGenerator<R> = transform { seq, seedOffset ->
	val offset = _components.config.offsetToDecidedOffset
	if (offset == null) {
		seq.mapIndexed { index, it -> transform(index, it, seedOffset) }
	} else {
		seq.mapIndexed { index, it ->
			transform(
				// expected that this overflows in the worst case
				index + offset,
				it,
				seedOffset
			)
		}
	}
}

/**
 * Maps the values `this` [ArbArgsGenerator] generates together with an index and a seed offset to a finite
 * [Sequence]`<R>` with the help of the given [transform] function and then flattens them so that the
 * resulting [ArbArgsGenerator] returns values of type [R].
 *
 * !! No backward compatibility guarantees !!
 * Reuse at your own risk
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset].
 *
 * @param transform The transformation function which takes a [T], an index and a seed offset and produces a
 *   finite [Sequence] of elements of type [R].
 *   The `seedOffset` is passed along the call chain and should be taken into account when using
 *   [ArbArgsGenerator.generate] inside the transform function.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of elements of the [Sequence] generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.flatMapIndexedInternal(
	transform: (index: Int, T, seedOffset: Int) -> Sequence<R>
): ArbArgsGenerator<R> = transform { seq, seedOffset ->
	val offset = _components.config.offsetToDecidedOffset
	if (offset == null) {
		seq.flatMapIndexed { index, it -> transform(index, it, seedOffset) }
	} else {
		seq.flatMapIndexed { index, it ->
			transform(
				// expected that this overflows in the worst case
				index + offset,
				it,
				seedOffset
			)
		}
	}
}

