@file:JvmName("SemiOrderedZipDependentKt")
@file:JvmMultifileClass

package com.tegonal.minimalist.generators

import ch.tutteli.kbox.Tuple2
import com.tegonal.minimalist.config._components
import com.tegonal.minimalist.config.arb
import com.tegonal.minimalist.generators.impl.InternalDangerousApi
import com.tegonal.minimalist.generators.impl.SemiOrderedFlatZipArbArgsGenerator
import com.tegonal.minimalist.generators.impl.mapIndexedInternal
import com.tegonal.minimalist.generators.impl.throwMaterialisingSemiOrderedArgsGeneratorNotSupported

/**
 * Creates for each generated value of type [A1] by `this` [SemiOrderedArgsGenerator] an [ArbArgsGenerator]
 * with the help of the given [otherFactory] and then [transform]s the value of `this` [SemiOrderedArgsGenerator]
 * with one value of the other [ArbArgsGenerator] to type [R].
 *
 * @param otherFactory Builds an [ArbArgsGenerator] based on a given value of type [A1].
 * @param transform The transformation function which takes an [A1] and [A2] and produces an [R].
 *
 * @param A1 The type of values generated by `this` [SemiOrderedArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [SemiOrderedArgsGenerator].
 *
 * @return The resulting [SemiOrderedArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
@OptIn(InternalDangerousApi::class)
fun <A1, A2, R> SemiOrderedArgsGenerator<A1>.zipDependent(
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>,
	transform: (A1, A2) -> R
): SemiOrderedArgsGenerator<R> = mapIndexedInternal { index, a1 ->
	transform(a1, this._components.arb.otherFactory(a1).generateOne(seedOffset = index))
}

/**
 * Creates for each generated value of type [A1] by `this` [SemiOrderedArgsGenerator] an [ArbArgsGenerator] with the
 * help of the given [otherFactory], generates the given [amount] of values, and zips them together with
 * the value of `this` [ArbArgsGenerator] to type [R].
 *
 * The resulting [SemiOrderedArgsGenerator] generates
 * [this.size][SemiOrderedArgsGenerator.size] * `amount` values before repeating.
 *
 * @param amount How many values of the generated [ArbArgsGenerator] shall be zipped.
 * @param otherFactory Builds another [ArbArgsGenerator] based on a given value of type [A1].
 *
 * @param A1 The type of values generated by `this` [ArbArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [Tuple2]`<A1, A2>`.
 *
 * @since 2.0.0
 */
fun <A1, A2> SemiOrderedArgsGenerator<A1>.flatZipDependent(
	amount: Int,
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>
): SemiOrderedArgsGenerator<Tuple2<A1, A2>> = flatZipDependent(amount, otherFactory, ::Tuple2)

/**
 * Creates for each generated value of type [A1] by `this` [SemiOrderedArgsGenerator] an [ArbArgsGenerator] with the
 * help of the given [otherFactory], generates the given [amount] of values, and [transform]s them together with
 * the value of `this` [ArbArgsGenerator] to type [R].
 *
 * The resulting [SemiOrderedArgsGenerator] generates
 * [this.size][SemiOrderedArgsGenerator.size] * `amount` values before repeating.
 *
 * @param amount How many values of the generated [ArbArgsGenerator] shall be zipped.
 * @param otherFactory Builds another [ArbArgsGenerator] based on a given value of type [A1].
 * @param transform The transformation function which takes an [A1] and [A2] and produces an [R].
 *
 * @param A1 The type of values generated by `this` [ArbArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <A1, A2, R> SemiOrderedArgsGenerator<A1>.flatZipDependent(
	amount: Int,
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>,
	transform: (A1, A2) -> R
): SemiOrderedArgsGenerator<R> = SemiOrderedFlatZipArbArgsGenerator(this, otherFactory, amount, transform)

@Suppress("UnusedReceiverParameter")
@Deprecated(
	""""
	Materialising means fixing the undefined/random part of an SemiOrderedArgsGenerator.
	Normally you do not want to turn an SemiOrderedArgsGenerator into an OrderedArgsGenerator as you basically
	loose the randomness you added in the first place.
	If you still want to do this, then use:

	let { g -> g.generate().take(g.size) }.toList().let(ordered::fromList).flatZipDependentMaterialised(otherFactory, transform)
	""",
	ReplaceWith("let { g -> g.generate().take(g.size) }.toList().let(ordered::fromList).flatZipDependentMaterialised(otherFactory, transform)"),
	level = DeprecationLevel.ERROR
)
fun <A1, A2, R> SemiOrderedArgsGenerator<A1>.flatZipDependentMaterialised(
	@Suppress("UNUSED_PARAMETER") otherFactory: OrderedExtensionPoint.(A1) -> OrderedArgsGenerator<A2>,
	@Suppress("UNUSED_PARAMETER") transform: (A1, A2) -> R
): OrderedArgsGenerator<R> = throwMaterialisingSemiOrderedArgsGeneratorNotSupported()
