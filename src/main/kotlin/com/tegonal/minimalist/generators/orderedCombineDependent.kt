package com.tegonal.minimalist.generators

import com.tegonal.minimalist.config._components
import com.tegonal.minimalist.config.config
import com.tegonal.minimalist.config.ordered

/**
 *  Generates [size][OrderedArgsGenerator.size] values, creates another [OrderedArgsGenerator] per value
 *  with the help of the given [otherFactory], materialises this other generator as well and combines its values with
 *  the corresponding value of `this` generator with the help of the given [transform] function to type [R].
 *
 * @param otherFactory Builds an [OrderedArgsGenerator] based on a given value of type [A1].
 * @param transform The transformation function which takes an [A1] and [A2] and produces an [R].
 *
 * @param A1 The type of values generated by `this` [OrderedArgsGenerator].
 * @param A2 The type of values generated by the given [OrderedArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [OrderedArgsGenerator].
 *
 * @return The resulting [OrderedArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <A1, A2, R> OrderedArgsGenerator<A1>.combineDependentMaterialised(
	otherFactory: OrderedExtensionPoint.(A1) -> OrderedArgsGenerator<A2>,
	transform: (A1, A2) -> R
): OrderedArgsGenerator<R> = transformMaterialised { seq ->
	val offsetToDecidedOffset = _components.config.offsetToDecidedOffset ?: 0
	seq.flatMapIndexed { index, a1 ->
		val otherGenerator = this._components.ordered.otherFactory(a1)
		val offset = index + offsetToDecidedOffset
		otherGenerator.generate(offset).take(otherGenerator.size).map { a2 ->
			transform(a1, a2)
		}
	}
}
