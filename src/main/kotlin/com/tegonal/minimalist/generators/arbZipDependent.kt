@file:JvmName("ArbZipDependentKt")
@file:JvmMultifileClass

package com.tegonal.minimalist.generators

import ch.tutteli.kbox.Tuple2
import com.tegonal.minimalist.generators.impl.flatMapIndexedInternal
import com.tegonal.minimalist.generators.impl.mapIndexedInternal
import com.tegonal.minimalist.utils.impl.checkIsPositive

/**
 * Creates for each generated value of type [A1] by `this` [ArbArgsGenerator] another [ArbArgsGenerator] with the
 * help of the given [otherFactory] and then [transform]s the value of `this` [ArbArgsGenerator]
 * with one value of the other [ArbArgsGenerator] to type [R].
 *
 * @param otherFactory Builds another [ArbArgsGenerator] based on a given value of type [A1].
 * @param transform The transformation function which takes an [A1] and [A2] and produces an [R].
 *
 * @param A1 The type of values generated by `this` [ArbArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <A1, A2, R> ArbArgsGenerator<A1>.zipDependent(
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>,
	transform: (A1, A2) -> R
): ArbArgsGenerator<R> = mapIndexedInternal { index, a1, seedOffset ->
	transform(a1, this._core.arb.otherFactory(a1).generateOne(index + seedOffset))
}

/**
 * Creates for each generated value of type [A1] by `this` [ArbArgsGenerator] another [ArbArgsGenerator] with the
 * help of the given [otherFactory], generates the given [amount] of values, and zips them together with
 * the value of `this` [ArbArgsGenerator].
 *
 * @param otherFactory Builds another [ArbArgsGenerator] based on a given value of type [A1].
 *
 * @param A1 The type of values generated by `this` [ArbArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [Tuple2]`<A1, A2>`.
 *
 * @since 2.0.0
 */
fun <A1, A2> ArbArgsGenerator<A1>.flatZipDependent(
	amount: Int,
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>,
): ArbArgsGenerator<Tuple2<A1, A2>> = flatZipDependent(amount, otherFactory, ::Tuple2)

/**
 * Creates for each generated value of type [A1] by `this` [ArbArgsGenerator] another [ArbArgsGenerator] with the
 * help of the given [otherFactory], generates the given [amount] of values, and [transform]s them together with
 * the value of `this` [ArbArgsGenerator] to type [R].
 *
 * @param amount How many values of the generated [ArbArgsGenerator] shall be zipped.
 * @param otherFactory Builds another [ArbArgsGenerator] based on a given value of type [A1].
 * @param transform The transformation function which takes an [A1] and [A2] and produces an [R].
 *
 * @param A1 The type of values generated by `this` [ArbArgsGenerator].
 * @param A2 The type of values generated by the other [ArbArgsGenerator] (built by the given [otherFactory]).
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <A1, A2, R> ArbArgsGenerator<A1>.flatZipDependent(
	amount: Int,
	otherFactory: ArbExtensionPoint.(A1) -> ArbArgsGenerator<A2>,
	transform: (A1, A2) -> R
): ArbArgsGenerator<R> {
	checkIsPositive(amount, "amount")
	return flatMapIndexedInternal { index, a1, seedOffset ->
		this._core.arb.otherFactory(a1).generate(index + seedOffset).take(amount).map { a2 ->
			transform(a1, a2)
		}
	}
}
