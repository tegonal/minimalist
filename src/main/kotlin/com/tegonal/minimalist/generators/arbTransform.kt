// --------------------------------------------------------------------------------------------------------------------
// automatically generated, don't modify here but in:
// gradle/code-generation/src/main/kotlin/code-generation.generate.gradle.kts => generate
// --------------------------------------------------------------------------------------------------------------------
package com.tegonal.minimalist.generators

import com.tegonal.minimalist.config.MinimalistConfig
import com.tegonal.minimalist.config._components
import com.tegonal.minimalist.config.config
import com.tegonal.minimalist.generators.impl.ArbArgsGeneratorTransformer

/**
 * Maps the values `this` [ArbArgsGenerator] generates to type [R] with the help of the given [transform] function.
 *
 * @param transform The transformation function which takes a [T] and produces an [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.map(transform: (T) -> R): ArbArgsGenerator<R> =
	// TODO 3.0.0 no need to define the seq parameter (we can use it) once we switch to api/languageVersion 2.x
	this.transform { seq -> seq.map(transform) }

/**
 * Maps the values `this` [ArbArgsGenerator] generates together with an index to type [R] with the help of the
 * given [transform] function.
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset].
 *
 * Use the overload which provides the `seedOffset` in case you use [ArbArgsGenerator.generate] in side the transform
 * function, this way you can pass on the `seedOffset` to [ArbArgsGenerator.generate].
 *
 * @param transform The transformation function which takes a [T] and an index and produces an [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.mapIndexed(transform: (index: Int, T) -> R): ArbArgsGenerator<R> =
	mapIndexed { index, it, seedOffset -> transform(index, it) }

/**
 * Maps the values `this` [ArbArgsGenerator] generates together with an index to type [R] with the help of the
 * given [transform] function.
 *
 * In case [MinimalistConfig.offsetToDecidedOffset] is `null` or `0` the index starts at `0` otherwise at
 * [MinimalistConfig.offsetToDecidedOffset].
 *
 * @param transform The transformation function which takes a [T] and an index and produces an [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.mapIndexed(transform: (index: Int, T, seedOffset: Int) -> R): ArbArgsGenerator<R> =
	this.transform { seq, seedOffset ->
		val offset = _components.config.offsetToDecidedOffset
		if (offset == null) {
			seq.mapIndexed { index, it -> transform(index, it, seedOffset) }
		} else {
			seq.mapIndexed { index, it -> transform(index + offset, it, seedOffset) }
		}
	}

/**
 * Filters the [Sequence] of values `this` [ArbArgsGenerator] will [generate][ArbArgsGenerator.generate] which
 * match the given [predicate] - should not filter out all values otherwise it will break the [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own RandomArgsGenerator
 * which only generates the desired values instead of filtering as `this` [ArbArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that matches the given [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be kept in the sequence, otherwise `false`.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates only values for which
 *   the given [predicate] returns `true`.
 *
 * @since 2.0.0
 */
fun <T> ArbArgsGenerator<T>.filter(predicate: (T) -> Boolean): ArbArgsGenerator<T> =
	// TODO 3.0.0 no need to define the seq parameter (we can use it) once we switch to api/languageVersion 2.x
	this.transform { seq -> seq.filter(predicate) }

/**
 * Filters the [Sequence] of values `this` [ArbArgsGenerator] will [generate][ArbArgsGenerator.generate] which
 * do **not** match the given [predicate] - should not filter out all values otherwise it will break the
 * [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own RandomArgsGenerator
 * which only generates the desired values instead of filtering as `this` [ArbArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that does not match the given
 * [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be filtered out, otherwise `false`.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates only values for which
 *   the given [predicate] returns `false`.
 *
 * @since 2.0.0
 */
fun <T> ArbArgsGenerator<T>.filterNot(predicate: (T) -> Boolean): ArbArgsGenerator<T> =
	// TODO 3.0.0 no need to define the seq parameter (we can use it) once we switch to api/languageVersion 2.x
	this.transform { seq -> seq.filterNot(predicate) }

/**
 * Transforms the [Sequence] `this` [ArbArgsGenerator] will generate into a [Sequence] of type [R] and thus creating a
 * [ArbArgsGenerator] of type [R].
 *
 * Note that the resulting sequence must still be an infinite stream of values.
 *
 * Use the overload which provides the `seedOffset` in case you use [ArbArgsGenerator.generate] in side the transform
 * function, this way you can pass on the `seedOffset` to [ArbArgsGenerator.generate].
 *
 * @param transform The transformation function which takes a [Sequence] of type [T] and
 *   produces a [Sequence] of type [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.transform(transform: (Sequence<T>) -> Sequence<R>): ArbArgsGenerator<R> =
	transform { seq, seedOffset -> transform(seq) }


/**
 * Transforms the [Sequence] `this` [ArbArgsGenerator] will generate into a [Sequence] of type [R] and thus creating a
 * [ArbArgsGenerator] of type [R].
 *
 * Note that the resulting sequence must still be an infinite stream of values.
 *
 * @param transform The transformation function which takes a [Sequence] of type [T] and
 *   produces a [Sequence] of type [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.transform(transform: (Sequence<T>, seedOffset: Int) -> Sequence<R>): ArbArgsGenerator<R> =
	ArbArgsGeneratorTransformer(this, transform)
