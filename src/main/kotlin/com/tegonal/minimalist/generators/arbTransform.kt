package com.tegonal.minimalist.generators

import com.tegonal.minimalist.generators.impl.ArbArgsGeneratorTransformer

/**
 * Maps the values `this` [ArbArgsGenerator] generates to type [R] with the help of the given [transform] function.
 *
 * @param transform The transformation function which takes a [T] and produces an [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.map(transform: (T) -> R): ArbArgsGenerator<R> =
	transform { seq -> seq.map(transform) }

/**
 * Filters the [Sequence] of values `this` [ArbArgsGenerator] will [generate][ArbArgsGenerator.generate] which
 * match the given [predicate] - should not filter out all values otherwise it will break the [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own [ArbArgsGenerator]
 * which only generates the desired values instead of filtering as `this` [ArbArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that matches the given [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be kept in the sequence, otherwise `false`.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates only values for which
 *   the given [predicate] returns `true`.
 *
 * @since 2.0.0
 */
fun <T> ArbArgsGenerator<T>.filter(predicate: (T) -> Boolean): ArbArgsGenerator<T> =
	transform { seq -> seq.filter(predicate) }

/**
 * Filters the [Sequence] of values `this` [ArbArgsGenerator] will [generate][ArbArgsGenerator.generate] which
 * do **not** match the given [predicate] - should not filter out all values otherwise it will break the
 * [ArgsGenerator] contract.
 *
 * Also be aware of that in terms of performance, you might be better off constructing an own [ArbArgsGenerator]
 * which only generates the desired values instead of filtering as `this` [ArbArgsGenerator] could potentially
 * generate a large number of values you are not interested in before generating one that does not match the given
 * [predicate].
 *
 * @param predicate which should return `true` for a given value if it shall be filtered out, otherwise `false`.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates only values for which
 *   the given [predicate] returns `false`.
 *
 * @since 2.0.0
 */
fun <T> ArbArgsGenerator<T>.filterNot(predicate: (T) -> Boolean): ArbArgsGenerator<T> =
	transform { seq -> seq.filterNot(predicate) }


/**
 * Instead of emitting the generated values directly, it takes chunks of [size], puts them into a [List] and returns it.
 *
 * @param size the size of the resulting [List]s.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 *
 * @return The chunked values as list.
 *
 * @since 2.0.0
 */
fun <T> ArbArgsGenerator<T>.chunked(size: Int): ArbArgsGenerator<List<T>> =
	transform { seq -> seq.chunked(size) }

/**
 * Instead of emitting the generated values directly, it takes chunks of [size], puts them into a [List] and lets
 * it [transform] into [R].
 *
 * @param size the size of the resulting [List]s.
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.chunked(size: Int, transform: (List<T>) -> R): ArbArgsGenerator<R> =
	transform { seq -> seq.chunked(size, transform) }


/**
 * Transforms the [Sequence] `this` [ArbArgsGenerator] will generate into a [Sequence] of type [R] and thus creating a
 * [ArbArgsGenerator] of type [R].
 *
 * Note that the resulting sequence must still be an infinite stream of values.
 *
 * Use the overload which provides the `seedOffset` in case you use [ArbArgsGenerator.generate] in side the transform
 * function, this way you can pass on the `seedOffset` to [ArbArgsGenerator.generate].
 *
 * @param transform The transformation function which takes a [Sequence] of type [T] and
 *   produces a [Sequence] of type [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.transform(transform: (Sequence<T>) -> Sequence<R>): ArbArgsGenerator<R> =
	transform { seq, _ -> transform(seq) }


/**
 * Transforms the [Sequence] `this` [ArbArgsGenerator] will generate into a [Sequence] of type [R] and thus creating a
 * [ArbArgsGenerator] of type [R].
 *
 * Note that the resulting sequence must still be an infinite stream of values.
 *
 * @param transform The transformation function which takes a [Sequence] of type [T] and
 *   produces a [Sequence] of type [R].
 *
 * @param T The type of values generated by `this` [ArbArgsGenerator].
 * @param R the type of values generated by the resulting [ArbArgsGenerator].
 *
 * @return The resulting [ArbArgsGenerator] which generates values of type [R].
 *
 * @since 2.0.0
 */
fun <T, R> ArbArgsGenerator<T>.transform(transform: (Sequence<T>, seedOffset: Int) -> Sequence<R>): ArbArgsGenerator<R> =
	ArbArgsGeneratorTransformer(this, transform)
